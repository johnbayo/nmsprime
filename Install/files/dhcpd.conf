#
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
#


#
# global
#
authoritative;
deny bootp;

option ntp-servers ntp.org;
ping-check true;
update-conflict-detection false;

# The algorithm and key used for dynamic DNS updates - Attention: has to be bevor global.conf because key is needed there
key dhcpupdate {
	algorithm hmac-md5;
	secret key==;
}

# MTA Activation
option space ccc;
# 0.0.0.0 to disable mta
option ccc.dhcp-server-1 code 1 = ip-address;
option ccc.SecondaryDHCPServer code 2 = ip-address;
option ccc.provision-server code 3 = {unsigned integer 8, string};
#option ccc.provision-server code 3 = {unsigned integer 8, ip-address};
option ccc.realm code 6 = string;
option ccc-encapsulation code 122 = encapsulate ccc;


include "/etc/dhcp/nms/global.conf";


#
# DNS && DDNS
#
ddns-updates on;
ddns-update-style interim;

update-static-leases on;
#update-optimization false; # delete and add everytime a client boots, only for debug
#update-conflict-detection false;


#
# listening interfaces for dhcp
# NOTE: Declare all management subnets here
#
shared-network ETHERNET
{
	subnet 10.0.254.0 netmask 255.255.255.0
	{
		deny booting;
	}
}


#
# INCLUDES: Hosts
#
include "/etc/dhcp/nms/modems-host.conf";
include "/etc/dhcp/nms/modems-clients-public.conf";
include "/etc/dhcp/nms/endpoints-host.conf";
include "/etc/dhcp/nms/mta.conf";


#
# LOG
#
# if mac of relay agent is different than mac of hardware than it's a device behind a modem
if ((exists agent.remote-id) and (not (binary-to-ascii(16, 8,":", substring(hardware,1,6)) = binary-to-ascii(16,8,":", option agent.remote-id)) ))
{
	# log dhcp discover of device behind modem
	if (binary-to-ascii(10, 8, ".", option dhcp-message-type) = "1")
	{
		if (substring(option vendor-class-identifier,0,4) = "pktc")
		{
			log(info, concat("DHCPDISCOVER received of MTA ", binary-to-ascii(16, 8,":", substring(hardware,1,6)),
				" of Modem ", binary-to-ascii(16, 8, ":", option agent.remote-id)));
		}
		else
		{
			log(info, concat("DHCPDISCOVER received of CPE ", binary-to-ascii(16, 8,":", substring(hardware,1,6)),
				" of Modem ", binary-to-ascii(16, 8, ":", option agent.remote-id)));
		}
	}

	on commit
	{
		if (substring(option vendor-class-identifier,0,4) = "pktc")
		{
			log(info, concat(
				"MTA ", binary-to-ascii(16, 8,":", substring(hardware,1,6)),
				" of Modem ", binary-to-ascii(16, 8, ":", option agent.remote-id),
				" is now ONLINE with IP ", binary-to-ascii(10, 8, ".", leased-address) ));
		}
		else
		{
			log(info, concat(
				"CPE ", binary-to-ascii(16, 8,":", substring(hardware,1,6)),
				" of Modem ", binary-to-ascii(16, 8, ":", option agent.remote-id),
				" is now ONLINE with IP ", binary-to-ascii(10, 8, ".", leased-address) ));
		}
	}
}

#if ((substring(option vendor-class-identifier,0,6) != "docsis") and (substring(option vendor-class-identifier,0,4) != "pktc"))
#{
#	on commit
#	{
#		execute("/var/www/lara/vds.sh", binary-to-ascii(10, 32, ".", encode-int (lease-time, 32)), binary-to-ascii(16, 8, ":", option agent.remote-id), binary-to-ascii(10, 8, ".", leased-address));
#	}
#}


#
# DEBUG - bsas: Sniffing
#
#on commit {
#	execute("/usr/local/bin/sniff.sh", "commit",
#		binary-to-ascii(16, 8, ":", substring(hardware,1,6)),
#		binary-to-ascii(10, 8, ".", leased-address),
#		pick-first-value(encode-int(lease-time,32),"-"),
#		binary-to-ascii(16, 8, ":", packet(0,1500))
#	);
#}

#on expiry {
#	execute("/usr/local/bin/sniff.sh", "expiry",
#		binary-to-ascii(10, 8, ".", leased-address),
#		encode-int(lease-time,32),
#		binary-to-ascii(16, 8, ":", packet(0,1500))
#	);
#}


#on release {
#	execute("/usr/local/bin/sniff.sh", "release",
#		binary-to-ascii(10, 8, ".", leased-address),
#		encode-int(lease-time,32),
#		binary-to-ascii(16, 8, ":", packet(0,1500))
#	);
#}


#
# INCLUDES: Subnets of Shared Networks (cmts)
#
